<head>
  <link rel="stylesheet" href="style.css" />
  <link rel="manifest" href="manifest.json" />
  <meta
    name="apple-mobile-web-app-status-bar-style"
    content="black-translucent"
  />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
  />
</head>

<body>
  <div class="app-ui">
    <div class="canvas-ui">
      <div class="canvas-controls">
        <button id="clear"><i>üßΩ</i>Clear Everything</button>
        <div class="flex-bottom">
          <button id="createArt" disabled>
            <i>üåà</i>
            <span id="createButtonText">Create</span>
          </button>
        </div>
      </div>

      <div class="canvas-container">
        <canvas id="canvas-pad" class="canvas-pad"></canvas>
      </div>

      <div class="canvas-controls">
        <button id="undo"><i>‚Ü©Ô∏è</i>Undo</button>
        <div class="flex-bottom">
          <button id="recordPrompt">
            <i id="recordButtonIcon">üé§</i>
            <span id="recordButtonText">Record Prompt</span>
          </button>
        </div>
      </div>
    </div>

    <div class="create-progress-container">
      <progress id="create-progress" value="0" max="100"></progress>
      <!--
            <div class="center-text">
                Look up at the big screen to see your masterpiece!
            </div>
            -->
    </div>

    <div class="prompt-container">
      <!-- Fancy trick to get an auto-expanding textarea: https://css-tricks.com/auto-growing-inputs-textareas/ -->
      <span
        role="textbox"
        id="prompt-input"
        class="prompt-input"
        contentEditable="true"
        enterkeyhint="done"
      ></span>
    </div>
  </div>

  <div class="creation-container flex-center">
    <div>
      <div class="creation-output">
        <img id="output" />
      </div>
    </div>
  </div>

  <!-- Source: https://github.com/szimek/signature_pad -->
  <!-- <script src="https://cdn.jsdelivr.net/npm/signature_pad@4.0.0/dist/signature_pad.umd.min.js"></script> -->
  <script src="js/vendor/signature_pad.umd.min.js"></script>
  <!-- Source: https://github.com/muaz-khan/RecordRTC/tree/master -->
  <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/RecordRTC/5.6.2/RecordRTC.js"></script> -->
  <script src="js/vendor/RecordRTC.js"></script>
  <script src="js/lib.js"></script>
  <script>

    // Prevent double-tap zooming on iOS
    let doubleTouchStartTimestamp = 0;
    document.addEventListener(
      "touchstart",
      function (event) {
        const now = +new Date();
        if (doubleTouchStartTimestamp + 500 > now) {
          event.preventDefault();
        }
        doubleTouchStartTimestamp = now;
      },
      { capture: true, passive: false }
    );

    // Always keep the canvas square
    function resizeCanvas() {
      const canvasContainer = document.querySelector(".canvas-container");
      const canvas = document.querySelector("canvas");
      const padding = 0;
      const canvasSize = Math.min(
        canvasContainer.clientHeight,
        canvasContainer.clientWidth
      );
      canvas.width = canvasSize - padding;
      canvas.height = canvasSize - padding;
    }
    resizeCanvas();
    window.addEventListener("resize", resizeCanvas, { passive: true });

    const root = document.documentElement;

    const actionEvent = isIOS() ? "touchstart" : "click";

    const creationContainer = document.querySelector(".creation-container");
    const creationOutputContainer = document.querySelector(".creation-output");
    const progressBarContainer = document.querySelector(
      ".create-progress-container"
    );
    const progressBar = document.getElementById("create-progress");

    const promptInput = document.getElementById("prompt-input");
    const defaultPromptPlaceholder = "Tap the üé§ button to record a prompt";

    // When user taps "Done", blur the input so the keyboard goes away
    promptInput.addEventListener('keydown', event => {
      if (event.keyCode === 13) { // Enter
        event.preventDefault();
        promptInput.blur();
      }
    })

    function updatePromptPlaceholder(newPlaceholder) {
      root.style.setProperty("--prompt-placeholder", `"${newPlaceholder}"`);
    }
    updatePromptPlaceholder(defaultPromptPlaceholder);

    const canvas = document.querySelector("canvas");
    const signaturePad = new SignaturePad(canvas, {
      backgroundColor: "rgb(255, 255, 255)", // set background color to white
    });

    let recorder = null;

    const createButton = document.getElementById("createArt");
    const createButtonText = document.getElementById("createButtonText");
    const defaultCreateButtonText = createButtonText.textContent;

    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.get("hide_output") == "true") {
      creationOutputContainer.style.display = "none";
      document.body.style.overflow = "hidden";
    }

    function updateCreateButtonState() {
      createButton.disabled = signaturePad.isEmpty() || !promptInput.innerText;
    }

    const clearButton = document.getElementById("clear");
    clearButton.addEventListener(actionEvent, async function () {
      signaturePad.clear();
      promptInput.innerText = "";

      hideElement(creationOutputContainer);
      hideElement(progressBarContainer);

      createButtonText.textContent = defaultCreateButtonText;
      updateCreateButtonState();

      try {
        await fetch("/clear", { method: "POST" });
      } catch {
        // ignore
      }
    });

    async function generateArt() {
      if (signaturePad.isEmpty() || !promptInput.innerText) {
        return;
      }

      createButton.disabled = true;
      showElement(progressBarContainer);
      updateProgressOverNSeconds(progressBar, AVG_SEC_TO_CREATE);

      const img_data = signaturePad.toDataURL("image/jpg");

      const requestPayload = {
        scribble_control_png_b64: img_data,
        prompt: promptInput.innerText,
      };

      const response = await fetch("/generate", {
        method: "POST",
        mode: "cors",
        cache: "no-cache",
        credentials: "same-origin",
        headers: { "Content-Type": "application/json" },
        referrerPolicy: "no-referrer",
        body: JSON.stringify(requestPayload),
      });
      const respData = await response.json();

      hideElement(progressBarContainer);
      const outputImg = document.getElementById("output");
      if (outputImg) {
        outputImg.src = respData["img_b64"];
      }

      showElement(creationOutputContainer);
      updateCreateButtonState();
      createButtonText.textContent = "Recreate";
    }
    createButton.addEventListener(actionEvent, generateArt);

    const undoButton = document.getElementById("undo");
    undoButton.addEventListener(actionEvent, function () {
      var data = signaturePad.toData();
      if (data) {
        data.pop(); // remove the last dot or line
        signaturePad.fromData(data);
      }
    });

    const recordPromptButton = document.getElementById("recordPrompt");
    const recordButtonText = document.getElementById("recordButtonText");
    const recordButtonIcon = document.getElementById("recordButtonIcon");
    recordPromptButton.addEventListener(actionEvent, async () => {
      const recorderState = await recorder?.getState();
      if (recorderState != "recording") {
        recordPromptButton.disabled = true;
        promptInput.innerText = "";

        updatePromptPlaceholder("Setting up microphone...");
        let stream = await navigator.mediaDevices.getUserMedia({
          audio: {
            echoCancellation: true,
          },
        });
        firstRecording = false;

        recorder = new RecordRTCPromisesHandler(stream, {
          type: "audio",
          recorderType: StereoAudioRecorder, // required to record .wav
          mimeType: "audio/wav",
        });
        recorder.startRecording();

        updatePromptPlaceholder("Recording. Tap again to stop...");
        recordPromptButton.disabled = false;
        recordButtonText.textContent = "Stop Recording";
        recordButtonIcon.textContent = "‚è∏";
      } else {
        if (!recorder) return;

        recordPromptButton.disabled = true;
        updatePromptPlaceholder("Processing your voice...");

        await recorder.stopRecording();
        let audioBlob = await recorder.getBlob();

        let formData = new FormData();
        formData.append("audio_file", audioBlob, "recording.wav");

        try {
          const resp = await fetch("/transcribe", {
            method: "POST",
            body: formData,
          });
          const respData = await resp.json();
          const transcription = respData["transcription"];

          promptInput.innerText = transcription;

          updatePromptPlaceholder(defaultPromptPlaceholder);
          recordButtonText.textContent = "Record Again";
          recordButtonIcon.textContent = "üé§";

          generateArt();
        } finally {
          recordPromptButton.disabled = false;
          try {
            await recorder.destroy();
          } catch (e) {
            console.error("Failed to destroy RecordRTC", e);
          }
          recorder = null;
        }
      }
    });

    signaturePad.addEventListener("endStroke", updateCreateButtonState);
    promptInput.addEventListener("input", updateCreateButtonState);
  </script>
</body>
