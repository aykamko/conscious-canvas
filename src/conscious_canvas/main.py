import logging
import shutil
import typing
import uuid
from enum import Enum

from fastapi import FastAPI, Form, UploadFile, WebSocket
from fastapi.staticfiles import StaticFiles
from pydantic import BaseModel
from websockets.exceptions import WebSocketException
from whispercpp import Whisper

from .a1111 import generate_a1111_controlnet, generate_a1111_prompt_only
from .async_util import YieldingQueue
from .image_util import pil_image_from_b64, pil_image_to_b64

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


ProjectionEventType = Enum(
    "ProjectionEventType",
    [
        "PROJECTION_CLIENT_CONNECTED",
        "GENERATION_STARTING",
        "ARTWORK_GENERATED",
        "CLEARED",
    ],
)

projection_event_queue = YieldingQueue()


class ProjectionEvent(BaseModel):
    event_type: ProjectionEventType


class ProjectionClientConnectedEvent(ProjectionEvent):
    event_type: ProjectionEventType = ProjectionEventType.PROJECTION_CLIENT_CONNECTED
    client_id: uuid.UUID


class GenerationStartingEvent(ProjectionEvent):
    event_type: ProjectionEventType = ProjectionEventType.GENERATION_STARTING
    scribble_b64: str
    prompt: str
    has_scribble: bool


class ArtworkGeneratedEvent(ProjectionEvent):
    event_type: ProjectionEventType = ProjectionEventType.ARTWORK_GENERATED
    scribble_b64: str
    prompt: str
    image_b64: str
    has_scribble: bool


class ClearEvent(ProjectionEvent):
    event_type: ProjectionEventType = ProjectionEventType.CLEARED


class GeneratePayload(BaseModel):
    scribble_control_png_b64: str
    prompt: str
    has_scribble: bool


app = FastAPI()

whisper = Whisper("base")


def _get_speech_segments(segments: typing.List[str]) -> typing.List[str]:
    """Get all speech segments. Non-speech, such as "[Music]", "*inaudible*", "(laughter)", are
    filtered out.

    Non-speech segments can be identified by special characters `[]()*`.

    Args:
        - segments: A list of transcribed segments generated by whispercpp.

    Returns a list of speech segments.
    """
    return [seg for seg in segments if seg.strip()[0] not in "[(*"]


@app.post("/generate")
async def generate(payload: GeneratePayload):
    scribble_byte_len = len(payload.scribble_control_png_b64)

    pil_img = pil_image_from_b64(payload.scribble_control_png_b64).convert("RGB")

    await projection_event_queue.put(
        GenerationStartingEvent(
            scribble_b64=payload.scribble_control_png_b64,
            prompt=payload.prompt,
            has_scribble=payload.has_scribble,
        )
    )
    if payload.has_scribble:
        result_img = await generate_a1111_controlnet(pil_img, payload.prompt)
    else:
        result_img = await generate_a1111_prompt_only(payload.prompt)

    b64_converted = pil_image_to_b64(result_img)

    await projection_event_queue.put(
        ArtworkGeneratedEvent(
            scribble_b64=payload.scribble_control_png_b64,
            prompt=payload.prompt,
            image_b64=b64_converted,
            has_scribble=payload.has_scribble,
        )
    )

    return {
        "message": f"scribble_byte_len: {scribble_byte_len}",
        "img_b64": b64_converted,
    }


@app.post("/transcribe")
async def transcribe(audio_file: typing.Annotated[UploadFile, Form()]):
    TEMP_FILE = "recording.wav"
    with open(TEMP_FILE, "wb") as out_file:
        shutil.copyfileobj(audio_file.file, out_file)

    embedding = whisper.transcribe(TEMP_FILE)
    segments = whisper.extract_text(embedding)
    logger.debug("Transcribed segments: %s", segments)
    text = "".join(_get_speech_segments(segments=segments)).strip()
    logger.info("Transcribed text: %s", text)

    return {"transcription": text}


@app.post("/clear")
async def clear():
    await projection_event_queue.put(ClearEvent())
    return {"success": True}


@app.websocket("/projection-ws")
async def websocket_endpoint(websocket: WebSocket):
    await websocket.accept()
    client_id = uuid.uuid4()
    await projection_event_queue.put(ProjectionClientConnectedEvent(client_id=client_id))
    while True:
        event: ProjectionEvent = await projection_event_queue.get()
        payload = {}
        if event.event_type == ProjectionEventType.PROJECTION_CLIENT_CONNECTED:
            if event.client_id != client_id:
                return  # new client connected, aborting this one
        else:
            payload = event.dict()
            payload["event_type"] = payload["event_type"].name
            logger.info("Sending event: %s", payload["event_type"])

        try:
            await websocket.send_json(payload)
        except WebSocketException:
            logger.info("Client disconnected")
            return


class NoCacheStaticFiles(StaticFiles):
    def is_not_modified(self, response_headers, request_headers) -> bool:
        return False

    def file_response(self, *args, **kwargs):
        resp = super().file_response(*args, **kwargs)
        resp.headers["Cache-Control"] = "no-cache"
        return resp


app.mount("/", NoCacheStaticFiles(directory="web_static", html=True), name="web_static")
